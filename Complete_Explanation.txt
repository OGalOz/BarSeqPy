    TODO:
        Run . testPy.sh 4

        How do you explain the whole 'strain Pseudo Count' and strainFit Weight
               etc from analysis1 ?? 

        Why are lr and lrn exactly the same? (from BP4?)
        Why do they start so low down the number of genes?

        Get examples of intermediate variables in AvgStrainFitness, StrainPseudoCount, etc.
        strain_lr is not completely empty
        'normalize_per_strain_values' doesn't make sense (analysis2)
        strain_lrn is not returning any results
            Where is strain_lrn being computed?
                At function create_strain_lrn in analysis2

        specphe (specific phenotypes) and cofit not being computed (analysis3)
        No description for NormalizeByScaffold in analysis1

        Ask meaning of function:
        getStrainPseudoCount
    
    Vocabulary:
        exp_name: Experiment name, string, like 'set2IT008' the name of a specific experiment.
        SetName: Like 'set2', a more general collection of experiments, within which indexes 
                 define experiments.
        Date: The day on which an experiment may have occured
        Strain: associated with a row in all.poolcount, this refers to a unique mutation
                in the DNA of an organism, in that it had a transposon insertion.
                Each barcode and location is essentially a 'strain', and the number
                of times that strain appears is correlated with the number of
                reads found.

    Function Descriptions:
        create_strain_lrn: 
            We take the strain log ratios, which are created in the function 
            'StrainFitness' from analysis1 and we normalize them by finding
            the median over all the values from the same scaffolds and
            subtracting that from the log ratios.
            We also take a dataframe that is the gene log ratios - gene
            normalized log ratios, and if those exist at a read, then
            we subtract those instead of the median.

        AvgStrainFitness: Done for each experiment_name
            We take three main input variables:
                1. exp_used_strains: The used reads values from all_df, 
                    it is a pandas Series of values, whose index is the row number
                    from all.poolcount where it originated.
                2. t0_used: The sum of the t0 reads for this experiment,
                    taken from all_df, and summed over the columns whose
                    experiments are associated with the t0 value for
                    this experiment_name. This is also a pandas Series,
                    whose  indexes are exactly the same as for exp_used_strains.
                3. all_used_locId: The associated locusIds for the above
                    two pandas Series,
                    

            Within this function we create the following variables:
                strainWeight, strainFit_adjusted, strainSD.

                    strainWeight: comes from t0_used, and exp_used_strains
                    strainFit_adjusted: comes from t0_used, exp_used_strains,
                                        condPseudoCount, and t0PseudoCount.
                                        condPseudoCount and t0PseudoCount
                                        come from strainPseudoCount,
                                        which comes from geneFit1 and readratio,
                                        geneFit1 comes from strainFit,
                                        which is the simple computation
                                        you'd expect the program to do.
                                        



    Main Variables:
        strainsUsed:
            list<bool> Length of all_df which decides which of the 'strains'
            we actually use. Must pass two qualifications:
            The mean of the t0tot over the strain has to pass a threshold 
                'minT0Strain'
            The insertion location of the strain has to be between 0.1 and 0.9
            of a gene.

        What are main lengths and how do they relate to lengths of input variables?
        Main lengths:
            nAllStrains = number of rows ( all.poolcount )
            nAllStrainsCentral = number of rows in all.poolcount with 0.1<f<0.9
            nAllStrainsCentralGoodGenes = number of rows in all.poolcount with 0.1<f<0.9
                                          AND all locusIds are in the list 'GenesUsed'
                                            (27659 in Keio) - also known as nUsefulReads

            nAllStrainsCentralGoodGenes* = number of rows in all.poolcount with 0.1<f<0.9
                                          AND all locusIds are in the list 'GenesUsed12'
                                            (27659 in Keio) - also known as nUsefulReads
            nTotalGenes = number of rows (genes.GC)
            nGenesUsed = (len(genesUsed)) number of rows in genes.GC that we actually use
                        which is equivalent to the number of unique genes
                        that have good insertions in them. (1355 in Keio)
            nGenesUsed12 = (len(genesUsed12)) number of locusIds with a good amount of 
                            insertions in both halves of 'f' from all_df. Both df1 and df2 
                            in GeneFitness() have this number of rows.
            nGenesUsed* = either nGenesUsed or nGenesUsed12
            nExperiments = number of rows in experiments file
    

    Questions:
        Why are we normalizing by scaffold?
        There are issues with some outputs: fit_log_ratios_unnormalized_naive:
            The dataframe isn't combined, it's just two dataframes stacked on top of 
            one another.
        What does get StrainPseudoCount do?
        What does AvgStrainFitness do?


    Outputs:

    The Standard output columns are:
            locusId, sysName, desc experiment_1, experiment_2, ..., experiment_n
            where experiment_1 etc refer to the setName + Index values
            These often have the same number of rows and contain numerical values under 
            the various experiments.

    Throughout the following, these column data types are fixed:
        locusId (str): The gene ID, also known as 'locus ID'
        desc (str): Short description of what a gene does
        name (str): Name of the experiment, or name of a gene 
        strand (str): Either '+' or '-', indicating positive or minus strand, respectively.
        begin (int): Where the object of interest begins within a scaffold
        end (int): Where the object of interest ends within a scaffold
        sysName (str): Another identifier for a gene


        fit_logratios_unnormalized_naive: The fitness logratios that are unnormalized
                                        Have Standard output columns
        cofit: Contains columns:
            locusId, sysName, desc, hitId, cofit, rank, hitSysName, hitDesc

        fit_logratios:
                                        Have Standard output columns

        fit_quality:
            Has the following columns:
                name, short, t0set, num, nMapped, nPastEnd, nGenic, nUsed, gMed, gMedt0, 
                gMean, cor12, mad12, mad12c, mad12c_t0, opcor, adjcor, gccor, maxFit, u

        fit_standard_error_naive:
                                        Have Standard output columns

        fit_standard_error_obs:
                                        Have Standard output columns

        fit_genes: (Complete) The genes.GC file with an extra column called 'used' which
                        contains boolean values for whether or not the gene was used.
                        Contains the following columns:
                            locusId (str):
                            sysName (str):	
                            type (int): Identifier for the type of gene
                            scaffoldId (str):	
                            begin (int):	
                            end (int):	
                            strand (str): '+'|'-'	
                            name (str): typical name for gene, e.g. "thrL"	
                            desc (str): What does the gene do?
                            GC (float):	Fraction of nucleotides that is GC
                            nTA (int):	number of TAs?
                            used (bool): gene used in analysis?

        fit_t:
                                        Have Standard output columns

        gene_counts:
                                        Have Standard output columns

                    Counts the number of times insertions occured in that gene in a given experiment.

        high_fitness: 
            Hybrid of a few of the other tables: Columns:
            locusId, expName, fit, t, se, sdNaive, name, Group, Condition_1, 
            Concentration_1, Units_1, Media, short, u, maxFit, gMean, sysName, desc

        specific_phenotypes:
            locusId, sysName, desc, short, Group, Condition_1, Concentraion_1, Units_1, Condition_2, Concentration_2, Units_2

        strain_fit:
            barcode, rcbarcode, scaffold, strand, pos, locusId, f, used, enoughT0, experiment_1   experiment_2  ... experiment_n
            
        strong:
            locusId, name, t, lrn, sysName, desc, short
        expsUsed:
           All the column names from the input experiments file + the following four:
                num (int) (counts which experiment, 
                short (str): either 'Time0' or a brief description of experiment conditions,
                name (str): the experiment name, e.g. set2IT003 
                t0set (str): A date which refers to the time0 to which we compare this one 
        

    
    Breakpoint Outputs Explained:
        BP3:
            gene_fit:
                Number of rows = length of genesUsed as input to analysis1

        GeneFitResults:
            For each experiment name, there are 3 different important variables:
               gene_fit, strain_fit, strain_se
            
            The length of gene_fit is nGenesUsed
            The length of strain_fit is  nAllStrainsCentralGoodGenes (nUsefulReads)





    Program is divided into 7 phases:
        1. Data Preparation 1: Naming and formatting (labeling)
        2. Data Preparation 2: Accounting for Controls (Known as "Time0")
                a) Finding and Summing Controls
                b) Finding which strains and genes are good to use and pass thresholds.
        3. Computations 1: Log Ratios, T-scores and Normalizations
        4. Computations 2: Correlations and meta-statistics
        5. Computations 3: Cofitness and finding high fitness values
        6. Exporting and Visualizing Graphs
        7. Website building


    Requirements:
        Inputs:
            all.poolcount: List of 'strains'. If a transposon was inserted inside a gene,
                then the field locusId will no longer be empty, and the field 'f' will no
                longer be empty, since 'f' measures the fraction of the gene in which
                the transposon was inserted, i.e. if it was inserted in the 25th% of
                the gene in terms of length, then its 'f' would be 0.25.
                For each identifier for an experiment, we count the number of times
                that strain appears.


        
       All the locusIds in all.poolcount have to exist in the genes file (genes.GC)

       Experiments File:
        If you want to drop an experiment (row in experiments file), you must create a column
         called 'Drop' and write in "true" (upper or lower cases don't matter). You can leave
         this column in the other experiments as nothing. You can also remove the row representing
         the experiment from the file entirely.
        The 'SetName' column contains the setname (lane) the experiments come from, 
        where as the 'Index' is more specifically the exact solution. 
        So the 'SetName' + 'Index' indicates a unique collection.

        Don't allow users to add 'strainsUsed'
        

    Random:

        Individual Experiments are denoted both by a row in the 'Experiments' file, and by a SetName.Index;
        Either one can be thought of as an individual experiment. Eventually, the "." in the SetName.Index is
        removed, and we are left with just SetNameIndex.
        SetNames can also be thought of as "lanes".
        How should dates be labelled? always X1/X2/X3..? 
        On any given date, a few experiments are Time0 experiments. So for example on  
            "6/19/2014" there were a few experiments started out of "Keio_ML9_set2", and we 
            can store all of those experiments in a dict.

        t0tot takes dates and sums all columns of all_df (that are experiments) over those dates.
        t0gN takes it one step further, and sums over the rows that have the same locusIds and that
            have central insertions.
        


    Input function is through RunFEBA.py:


        The 'readratio' is the ratio between the sum of all final values for a setIndex Name
            from all.poolcount and the sum of the corresponding t0 values.
            It is used in calculating the Strain Fitness.

        The experiments file has to follow very specific requirements:
            If you want to Drop an experiment, you need to create a column
            for all your experiments called "Drop", and within that column
            you must add the value "TRUE" (or "True").
            The column 'name' must eventually be equivalent to the indexes
                in all.poolcount
            The column 'Group' must show if it's Time0 by saying 'Time0' when it
                is indeed a time0 element

        You can also add a list of set-index names to ignore



    ScaffoldId vs Scaffold as column name?
   
    The total number of rows in the dataframes is equivalent to the numbers of
        unique locusIds in strainLocus[strainsUsed].


    gene_fit_d:

    g -> genes
    lr -> log ratios
    lrn -> log ratios normalized
    lrn1 -> log ratios normalized 1st half
    q -> quality
    u -> used
    se -> standard error
    tmp -> temporary


        Stores combined data over all set_index_names.
            *All series/dataframes ave the exact same number of rows.
        g: A list of locusIds
        lr: Some rows are completely empty (?), whenever one col has values, 
            the other also has values.
        lr1/ lr2: If two columns, if one has value, the other has the opposite value 

        At the end of the program, gene_fit_d should have keys:
            'g', 'lrRaw', 'sd', 'sumsq', 'sdNaive', 'n', 'nEff', 'tot', 'tot0', 'lr', 
            'lrNaive', 'lrn', 'lr1', 'lr2', 'lrn1', 'lrn2', 'tot1', 'tot1_0', 'tot2', 
            'tot2_0', 'pseudovar', 'se', 't', 'version', 'q', 'genesUsed', 'strainsUsed', 
            'genesUsed12', 'gN', 't0_gN', 'strains', 'strain_lr', 'strain_se', 'high' 
    
    fitQuality:
        This returns a matrix with individual stats per setindexname. So if there are 4 set index names,
        e.g. set2IT001, set2IT002, set2IT003, set2IT004; You would get a matrix with the columns:
            nUsed, gMed, gMedt0, gMean, cor12, mad12, mad12c, mad12c_t0, opcor, adjcor, gccor, maxFit
        and the rows of the 4 set index names.

    Revisions:
        all_gN isn't used but created early on and stored as a variable (Why?)
        experiments DataFrame is updated at random times, e.g. in FEBA_Fit it is 
                updated to have 'short' set to Time0 if group is Time0, which could
                have been done earlier in the program, e.g. in 'RunFEBA'. Also,
                the t0set is created at a random point.
